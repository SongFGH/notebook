Title: 快速排序
Date: 2016-4-17       
Author: sndnyang  
Slug: quick-sort   
Category: 算法  
tags: cs, 算法  

[TOC]


## 欢迎在zhimind上学习

本教程将尽我所能，指导您理解、练习并掌握快速排序算法。虽然目前仅限于使用javascript, 但算法对其他语言是通用的， 具体的语言不会影响您的理解。

左侧是javascript输入控制台，现在先告诉我们您的名字, 请输入 `setName('您的昵称')`

另外，有一些有用的命令: 输入 `help()` 来查看帮助吧！

## 排序问题

现实中非常常见的一个问题就是， 给定一堆乱序的数字或名称， 给它们排好序。 

之前可能已经学过以下几种排序算法:

1. [冒泡排序](/index)
2. [选择排序](/index)
3. [插入排序](/index)
4. [归并排序](/index)
5. [堆排序](/index)

我们现在又要用新的方法实现了, 它就是 [快速排序]("http://baike.baidu.com/link?url=Ba5BF-czRTU7OYN7kOctQnw-ZNCAabQ2nPGTxg-vGRVf3oOtRjwr-_d5EjRbP6h4qmv2AmqmGKQD96n64ILWz4v1DEW0nFwuGlqmmVI-ZBVkF3Nb5U7zc4mpsVF1UYc4XQF802_gZGKvOsJAJ0hCf3XoxJPEjkLNh4XEAbvyC0eS00VoyIZkFYt_Bw5eWqme")。

在开始正题之前， 先来查看待排序数组 v[] 的数据 ， 请输入`print_list()` 

## 分治思想

不同于选择或冒泡排序逐个处理的暴力搜索思想， 我
们现在来考虑分治的思想

{%gapfill|提到排序和分治，你首先想到_算法@归并排序#什么排序算法#标准名字#没学过归并排序？不好意思啦%}


## 划分的方式

从中间位置划分，分后治之的是归并排序。

如果不指定位置划分， 有其他方法划分否？ 另外能否边分边治？

{%checkbox|还有哪些可能的划分方式?&随机&值大小&位置&不知道@值大小#位置不算入#你居然选随机和不知道？%}

## 怎么选值呢?

不按位置，那我们只能按实际值的大小来划分。

{%checkbox|那怎么选划分值呢？&随机一个&第一个&最后一个&中间那一个&平均值&中位数&不知道@随机一个@第一个@最后一个@中间那一个#标准教材最终会讲到任意一个#也就是平均值、中位数不知道#你居然选了不知道？%}

## 准备划分

既然已经知道了划分的k值， 那么现在就来划分数组了。

目标就是让小于k的数放到左边， 大于等于k的数在右边，k在中间 

想法是简单，可这不是废话吗？排好序的就有这性质啊。 那乱序的数组不排序怎么做呢？

# 分析初始和目标状态

关于初始状态，只知道

1. k在数组第一个位置
2. k左边没有数，为空
3. 右集合是一堆乱序数。 

反过来看目标状态，是不是也是三个集合：

1. k自己是一个集合
2. 比k小的数组成一个集合 
3. 不比k小的数组成一个集合（除k）

正好对应上

既然如此， 就定义两个空集合（k本身是一个集合）， 分别叫做 left, right.

请写代码`left=[],right=[]`

## 遍历划分

很简单， 我们只要遍历一遍数组v[]，将里面的元素按比k值的大小结果，相应地添加到left和right

请实现， 得到left, right结果

请从第二位开始从左往右遍历， 否则顺序不匹配， 也过不了

## 递归解决子问题

目前求得三个集合， k, 比k小， 不比k小。

然后要递归处理子问题， 

首先， 当问题规模 <= 1时， 不需要再划分， 直接返回该数组-- 作为递归出口
其次， 子问题处理完毕后， 三块集合要连接， 才能向更上层返回。

请基于前面几步， 编写一个递归函数quicksort， 并调用它来处理数组v[]


## 快速排序优化， 请待后续分解

以上部分是最容易实现的快速排序方法， 但有浪费一些空间， 教科书上最常见的不需要这部分空间, 会有一些小陷阱， 我暂时写不下去了--打算先写点别的

## 如何求解

所以现在问题就是 如何求 i(index), 就是k的目标位置

从初始状态开始， k 在第一个位置，而js数组下标从0开始， 所以 i = 0

{%radio|目标位置可以由什么直接决定?&不比k小的个数&比k大的个数&比k小的个数&和k相等的个数@比k小的个数#直接相关%}

## 那请找出比 k 小的值的个数 

so easy! 

请在得到该值后（直接数个数也行），建议用循环比较（文本框问题全部写成一行)，并保存到变量里， 输入`变量或值`

## 哪里不对？

看起来位置是知道了， 但感觉哪里不对？

{%radio|&哪里都不对&知道k位置，还不知道左右集合大小&只知道k位置，其他值没说& 有哪里不对@只知道k位置，其他值没说%}

## 能否在计算 k 位置的同时， 把集合划分好？



之前你是怎么统计 <k 的值的个数的？ 还记得吧？

从左往右扫描时（或从右往左），假设不扫描k所在的第一位

是不是 看到一个小的数，就加1呢？ 如果求的是 >= k 的个数， 也是类似的， 不是吗？



做成动画的话， 是不是 k 的位置往右移动了一格呢？

那有什么问题吗？

{%checkbox|&原位置留的坑怎么办？&不知道看到哪里了？&新位置的值怎么办？&这些都不是问题@原位置留的坑怎么办？@新位置的值怎么办？#选择题不太好提示啊~~~%}

## 向右移动到新位置

新位置上的值怎么办？

{%radio|&只用下标记位置&用临时变量保存起来@只用下标记位置%}

## 原位置怎么办？

{%radio|&留空&k&我也不知道&随便找个小于k的数填上&正看到的那个小于k的数来填上@正看到的那个小于k的数来填上%}

## 顺利？

上一步有什么问题？ 想想上上一步 新位置上的值是怎么处理的？

{%radio|&有问题？我不知道&位置只是下标,原位置的实际值会被覆盖&k的位置可能会乱掉@位置只是下标,原位置的实际值会被覆盖%}

## 如何避免覆盖？

当然是

{%radio|&两个位置的值进行交换&用临时变量保存@两个位置的值进行交换#临时变量保存能不能搞定， 其实没试过%}

## 回顾一下？

那我们脑海里的动画似乎可以顺利进行了

1. 选择好 k 的值——先假设是数组的第一个数， 当前位置是下标0
2. 数组从左往右扫描时（或从右往左）， 遍历时怎么处理？
3. 看到一个小于k的数，k的位置向右走一格， 原位置和扫描到的位置进行交换(即小于k的值被移到了k的左边，而在原位置上的数是之前扫描过的不小于k的数，交换后仍然保持在k的右边)。
4. 否则继续遍历， 直到遍历完整个数组。

好， 那我们开始走一遍

### 先选一个 k

请用代码选出当前数组的第一个值,及下标`i=0;k = ???`，请不要直接填写具体值

## 循环遍历

假设从左往右扫描， 


都说了边分边治，为什么不呢？难不成还等回来再处理？

那现在的问题就是， 在我们遍历时， 能不能顺便把小的扔在一起，不小于k的扔在一起？

假设现在左右两边集合都是空的，遍历时小的放到数组左端， 不小
的加到数组右端， 省略若干字和一步

但想想，这两个集合是互斥的，不重叠的，我把左边的搞好了，k就知道了， 右边自然就剩下并满足了，为什么要小也判断一下，大也判断一下

所以只需要在遍历时， 发现小的就放到数组左端， 像是去排队一样
, 一开始队伍长度为0， 所以我们定义一个变量`var set_length=0`, 也可以用队首队尾概念定为-1，问题都不大

现在请用代码实现 集合长度 变化过程 
`遍历；逐个处理；（这个暂时没想好 怎么算通过测试， 请随意输入）`.


是不是只要知道k 在目标状态时的位置， 并保证左边的都小于k, 右边的都大于等
于k， 就知道左右集合大小了呢， 至于它们内部需要有序吗？我们不管。
分后才治之？
## 正确实现
所以整个过程就是， 当遍历到某个值v[i]时，` if (v[i]小于k)
    {v[set_length] = v[i]; set_length++;} `

是不是有什么问题呢——对吧， v[set_length] 被覆盖了， 原来的
值就这么随意的get out了吗？所以， 我们不能简单地覆盖， 而是应该交换两个位置的值 

下面就请正确实现 整个划分过程吧， 一定要正确地划分！不然不让
过哦， 用很多算法书上的 while 循环或一些算法书上的for循环遍历都
可以，只要满足k 左边的值都小于k,右边的值都不小于k, 请使用已定义
变量 l 或 k 或 global_l, global_k， 代码写成一行 

请将 k 目标状态所在位置的值保存在 变量 global_l 中。

参考答案: 
`
    l = 1;
    for(var j = 1; j &lt v.length; j++){ // 这个for 循环要写成
    一行
    if (v[j] &lt k){ 
        swap(v, j, l);
        l++;
    }
    }
    swap(v, l-1, 0)
    global_l = l-1;
`

## 可以像归并排序那样分完再治吗？

**如果没学过归并排序， 以下几节不用细看** 

正如之前提到的， 在学习分治算法时， 老师通常会讲 归并排序和快速排序。

如果有学过[归并排序](/index),  应该有印象， 最常规的归并排序是先不断地递归划分成子问题，直到不可再划分， 等到返回时， 再将子问题进行合并。 所以是先分后治， 分完再治。

那快速排序可以这样吗？我们每层都可以求出划分的位置，是否可以 先递归求子问题， 再返回求解主问题？

{%radio|&可以&不可以@不可以#那就成不同划分方式的归并排序而已}
               
## 撒花庆祝！

Congratulations, {{ firstName }}, 你完成了快速排序的学习（中间
少了很多步还没写呢）。 如果觉得有意义, 但没完全掌握或希望复习的话， 用
`reset()`重新学习吧！

